# Coin Exploit Prevention - Testing Guide

This guide explains how to test the coin exploit prevention system locally.

## Prerequisites

1. **Start your local server:**
   ```bash
   cd backend
   npm run dev
   ```
   Server should run on `http://localhost:2000`

2. **Database Setup:**
   - Ensure PostgreSQL is running
   - Database should have the `coin_transactions` table with `metadata` column (JSONB)
   - Ensure `orders` table has `coins_used` column

3. **Test User:**
   - Create a test user or use an existing one
   - Note the user's email for testing

## Testing Scenarios

### Scenario 1: Normal Coin Usage (No Exploit)

**Goal:** Verify coins work normally when orders are not cancelled.

**Steps:**
1. **Place Order A** (₹1000) → User gets 50 coins (5% cashback)
   ```bash
   POST http://localhost:2000/api/orders
   {
     "customer_email": "test@example.com",
     "customer_name": "Test User",
     "shipping_address": { "name": "Test", "phone": "1234567890", "address": "Test Address" },
     "items": [{ "product_id": 1, "quantity": 1, "price": 1000 }],
     "subtotal": 1000,
     "total": 1000,
     "payment_method": "razorpay",
     "payment_status": "paid"
   }
   ```

2. **Place Order B** (₹1000) → User gets another 50 coins
   - Total coins: 100

3. **Place Order C** using 100 coins (₹1000 order, coins cover full amount)
   ```bash
   POST http://localhost:2000/api/orders
   {
     "customer_email": "test@example.com",
     "customer_name": "Test User",
     "shipping_address": { "name": "Test", "phone": "1234567890", "address": "Test Address" },
     "items": [{ "product_id": 1, "quantity": 1, "price": 1000 }],
     "subtotal": 1000,
     "total": 0,
     "coins_used": 100,
     "payment_method": "coins",
     "payment_status": "paid"
   }
   ```

4. **Verify:**
   - Check user's `loyalty_points` in database: Should be 0
   - Check `coin_transactions` table: Should have a `redeemed` transaction with metadata containing source orders
   - Metadata should show Order A and Order B as source orders

**Expected Result:** ✅ Coins deducted correctly, source orders tracked in metadata

---

### Scenario 2: Exploit Attempt (The Fix)

**Goal:** Verify that cancelling orders after using their coins is prevented.

**Steps:**
1. **Place Order A** (₹1000) → User gets 50 coins
   - Check balance: 50 coins

2. **Place Order B** (₹1000) → User gets another 50 coins
   - Check balance: 100 coins

3. **Place Order C** using 100 coins (₹1000 order)
   - Check balance: 0 coins
   - Note Order C's order number

4. **Cancel Order A** (the exploit attempt)
   ```bash
   PUT http://localhost:2000/api/cancellations/{cancellation_id}/approve
   ```
   Or use the cancellation endpoint:
   ```bash
   POST http://localhost:2000/api/cancellations/cancel
   {
     "order_number": "N-...", // Order A's order number
     "reason": "Test cancellation"
   }
   ```

5. **Verify Exploit Prevention:**
   - Check user's `loyalty_points`: Should be **-50** (negative balance!)
   - Check `coin_transactions` table:
     - Should have a `cashback_reversed` transaction
     - Metadata should show:
       - `original_cashback`: 50
       - `coins_used_in_other_orders`: 50 (coins from Order A used in Order C)
       - `affected_orders`: Array with Order C details
   - Check `admin_notifications` table:
     - Should have a notification with type `coin_exploit_prevention`
     - Should include details about affected orders

**Expected Result:** ✅ 
- User balance goes negative (-50 coins)
- System detects coins from Order A were used in Order C
- Coins are deducted from user's balance
- Admin is notified

---

### Scenario 3: Multiple Orders Using Same Source Coins

**Goal:** Test FIFO tracking when coins from one order are used in multiple orders.

**Steps:**
1. **Place Order A** (₹2000) → User gets 100 coins

2. **Place Order B** using 50 coins (₹500 order)
   - Uses 50 coins from Order A

3. **Place Order C** using 50 coins (₹500 order)
   - Uses remaining 50 coins from Order A

4. **Cancel Order A**

5. **Verify:**
   - User balance: -100 coins (both Order B and C used coins from Order A)
   - `affected_orders` in metadata should list both Order B and Order C

**Expected Result:** ✅ System tracks all orders that used coins from cancelled order

---

## Manual Testing with Database Queries

### Check User's Coin Balance
```sql
SELECT id, email, loyalty_points 
FROM users 
WHERE email = 'test@example.com';
```

### Check Coin Transactions
```sql
SELECT 
  id,
  amount,
  type,
  description,
  metadata,
  created_at
FROM coin_transactions
WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com')
ORDER BY created_at DESC;
```

### Check Source Order Tracking
```sql
-- View redeemed transactions with source orders
SELECT 
  ct.id,
  ct.amount,
  ct.type,
  ct.description,
  ct.metadata->>'source_orders' as source_orders,
  o.order_number
FROM coin_transactions ct
LEFT JOIN orders o ON ct.order_id = o.id
WHERE ct.user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND ct.type = 'redeemed'
ORDER BY ct.created_at DESC;
```

### Check Admin Notifications
```sql
SELECT 
  id,
  notification_type,
  title,
  message,
  metadata,
  created_at
FROM admin_notifications
WHERE notification_type = 'coin_exploit_prevention'
ORDER BY created_at DESC;
```

### Check Cancellation Reversal
```sql
SELECT 
  ct.id,
  ct.amount,
  ct.type,
  ct.description,
  ct.metadata,
  o.order_number
FROM coin_transactions ct
LEFT JOIN orders o ON ct.order_id = o.id
WHERE ct.user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND ct.type = 'cashback_reversed'
ORDER BY ct.created_at DESC;
```

---

## Automated Testing

Use the provided test script:

```bash
cd backend
npm run test:coin-exploit
```

Or run directly:
```bash
node backend/test-coin-exploit.js
```

See `test-coin-exploit.js` for the automated test script.

---

## What to Verify

### ✅ Success Indicators:

1. **Coin Source Tracking:**
   - When coins are used, `coin_transactions.metadata` contains `source_orders` array
   - Source orders are tracked in FIFO order
   - Each source order entry has: `transaction_id`, `order_id`, `order_number`, `amount`

2. **Exploit Prevention:**
   - When an order is cancelled, system checks if its coins were used elsewhere
   - If yes, coins are deducted from user's balance (can go negative)
   - Transaction is created with type `cashback_reversed`
   - Metadata includes affected orders

3. **Admin Notifications:**
   - Notification created when coins are deducted from other orders
   - Notification includes cancelled order, affected orders, and final balance

4. **Database Integrity:**
   - All transactions are properly recorded
   - Metadata is valid JSON
   - No orphaned records

### ❌ Failure Indicators:

- User can cancel orders and keep coins used in other orders
- Balance doesn't go negative when it should
- No admin notification when exploit is detected
- Source order tracking missing in metadata
- Database errors or invalid JSON in metadata

---

## Troubleshooting

### Issue: Coins not being tracked
- Check if `coin_transactions` table has `metadata` column (JSONB)
- Verify order creation includes `coins_used` parameter
- Check server logs for errors

### Issue: Cancellation not deducting coins
- Verify order status is set to 'cancelled'
- Check if cancellation endpoint is calling the coin reversal logic
- Look for errors in server logs

### Issue: Admin notification not created
- Check if Socket.IO is initialized (`io` parameter passed to cancellation function)
- Verify `admin_notifications` table exists
- Check server logs for notification errors

---

## Test Data Cleanup

After testing, you may want to clean up test data:

```sql
-- Delete test orders
DELETE FROM orders WHERE customer_email = 'test@example.com';

-- Delete test coin transactions
DELETE FROM coin_transactions 
WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com');

-- Reset user balance
UPDATE users 
SET loyalty_points = 0 
WHERE email = 'test@example.com';

-- Delete test admin notifications
DELETE FROM admin_notifications 
WHERE notification_type = 'coin_exploit_prevention';
```

---

## Next Steps

1. Run through all scenarios manually
2. Use the automated test script
3. Verify database records match expected results
4. Check admin panel for notifications
5. Test edge cases (partial coin usage, multiple cancellations, etc.)


