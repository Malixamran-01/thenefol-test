/**
 * Direct Database Test for Coin Exploit Prevention
 * Tests the exploit prevention logic directly via database without needing API server
 */

const { Pool } = require('pg')
require('dotenv').config()

const pool = new Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://postgres:2015127a@localhost:5432/nefol'
})

const TEST_USER_EMAIL = 'test@example.com'

async function getUserId() {
  const result = await pool.query('SELECT id FROM users WHERE email = $1', [TEST_USER_EMAIL])
  return result.rows[0]?.id
}

async function getUserBalance() {
  const result = await pool.query('SELECT loyalty_points FROM users WHERE email = $1', [TEST_USER_EMAIL])
  return result.rows[0]?.loyalty_points || 0
}

async function runDirectTest() {
  console.log('ðŸ§ª Direct Database Test - Coin Exploit Prevention\n')
  console.log(`ðŸ“§ Test User: ${TEST_USER_EMAIL}\n`)
  
  try {
    const userId = await getUserId()
    if (!userId) {
      console.log('âŒ Test user not found. Run: node setup-test-user.js')
      return
    }
    
    console.log('âœ… Test user found\n')
    
    // Step 1: Create Order A (â‚¹1000) - manually add 50 coins
    console.log('ðŸ“¦ Step 1: Creating Order A (â‚¹1000) â†’ Earns 50 coins')
    const orderAResult = await pool.query(`
      INSERT INTO orders (
        order_number, customer_email, customer_name,
        shipping_address, items, subtotal, total,
        payment_method, payment_status, status
      ) VALUES (
        'TEST-ORDER-A-' || EXTRACT(EPOCH FROM NOW())::bigint,
        $1, 'Test User',
        '{"name": "Test", "phone": "1234567890", "address": "Test"}'::jsonb,
        '[{"product_id": 1, "quantity": 1, "price": 1000, "name": "Test Product"}]'::jsonb,
        1000, 1000, 'razorpay', 'paid', 'confirmed'
      ) RETURNING id, order_number
    `, [TEST_USER_EMAIL])
    
    const orderA = orderAResult.rows[0]
    console.log(`   âœ… Order A created: ${orderA.order_number} (ID: ${orderA.id})`)
    
    // Add 50 coins (5% cashback)
    await pool.query(`
      UPDATE users SET loyalty_points = loyalty_points + 50 WHERE id = $1
    `, [userId])
    
    await pool.query(`
      INSERT INTO coin_transactions (user_id, amount, type, description, status, order_id)
      VALUES ($1, 50, 'earned', 'Cashback 5% for order ' || $2, 'completed', $3)
    `, [userId, orderA.order_number, orderA.id])
    
    const balanceAfterA = await getUserBalance()
    console.log(`   âœ… User balance: ${balanceAfterA} coins\n`)
    
    // Step 2: Create Order B using 50 coins
    console.log('ðŸ’° Step 2: Creating Order B using 50 coins (â‚¹500 order)')
    const orderBResult = await pool.query(`
      INSERT INTO orders (
        order_number, customer_email, customer_name,
        shipping_address, items, subtotal, total,
        payment_method, payment_status, status, coins_used
      ) VALUES (
        'TEST-ORDER-B-' || EXTRACT(EPOCH FROM NOW())::bigint,
        $1, 'Test User',
        '{"name": "Test", "phone": "1234567890", "address": "Test"}'::jsonb,
        '[{"product_id": 1, "quantity": 1, "price": 500, "name": "Test Product"}]'::jsonb,
        500, 0, 'coins', 'paid', 'confirmed', 50
      ) RETURNING id, order_number
    `, [TEST_USER_EMAIL])
    
    const orderB = orderBResult.rows[0]
    console.log(`   âœ… Order B created: ${orderB.order_number} (ID: ${orderB.id})`)
    
    // Deduct coins and track source
    await pool.query(`
      UPDATE users SET loyalty_points = loyalty_points - 50 WHERE id = $1
    `, [userId])
    
    await pool.query(`
      INSERT INTO coin_transactions (user_id, amount, type, description, status, order_id, metadata)
      VALUES ($1, -50, 'redeemed', 'Used 50 coins for order ' || $2, 'completed', $3, $4)
    `, [userId, orderB.order_number, orderB.id, JSON.stringify({
      source_orders: [{
        transaction_id: (await pool.query('SELECT id FROM coin_transactions WHERE order_id = $1 AND type = $2', [orderA.id, 'earned'])).rows[0].id,
        order_id: orderA.id,
        order_number: orderA.order_number,
        amount: 50
      }],
      coins_used: 50,
      order_number: orderB.order_number
    })])
    
    const balanceAfterB = await getUserBalance()
    console.log(`   âœ… User balance: ${balanceAfterB} coins\n`)
    
    // Step 3: Cancel Order A (The Exploit Test)
    console.log('ðŸ›¡ï¸ Step 3: Cancelling Order A (Exploit Prevention Test)')
    
    // Mark as delivered first
    await pool.query(`
      UPDATE orders SET status = 'delivered', delivered_at = NOW() WHERE id = $1
    `, [orderA.id])
    
    // Create cancellation
    const cancelResult = await pool.query(`
      INSERT INTO order_cancellations (
        order_id, order_number, user_id, cancellation_reason,
        cancellation_type, refund_amount, status
      ) VALUES ($1, $2, $3, 'Test cancellation', 'full', 1000, 'approved')
      RETURNING id
    `, [orderA.id, orderA.order_number, userId])
    
    await pool.query(`UPDATE orders SET status = 'cancelled' WHERE id = $1`, [orderA.id])
    
    console.log(`   âœ… Order A cancelled (Cancellation ID: ${cancelResult.rows[0].id})`)
    
    // Now simulate the exploit prevention logic
    const balanceBeforeCancel = await getUserBalance()
    console.log(`   ðŸ“Š Balance before cancellation: ${balanceBeforeCancel} coins`)
    
    // Find cashback coins from Order A
    const cashbackResult = await pool.query(`
      SELECT amount FROM coin_transactions
      WHERE user_id = $1 AND type = 'earned' AND order_id = $2 AND amount > 0
      ORDER BY created_at DESC LIMIT 1
    `, [userId, orderA.id])
    
    if (cashbackResult.rows.length > 0) {
      const cashbackCoins = cashbackResult.rows[0].amount
      
      // Find coins used from Order A in other orders
      const usedCoinsResult = await pool.query(`
        SELECT ct.id, ct.order_id, ct.amount, o.order_number, ct.metadata
        FROM coin_transactions ct
        LEFT JOIN orders o ON ct.order_id = o.id
        WHERE ct.user_id = $1
          AND ct.type = 'redeemed'
          AND ct.amount < 0
          AND ct.metadata IS NOT NULL
          AND ct.metadata::text LIKE '%' || $2::text || '%'
          AND (o.status IS NULL OR o.status NOT IN ('cancelled'))
      `, [userId, orderA.id.toString()])
      
      let totalCoinsToDeduct = cashbackCoins
      const affectedOrders = []
      
      for (const usedTx of usedCoinsResult.rows) {
        const metadata = typeof usedTx.metadata === 'string' ? JSON.parse(usedTx.metadata) : usedTx.metadata
        if (metadata && metadata.source_orders) {
          for (const sourceOrder of metadata.source_orders) {
            if (sourceOrder.order_id === orderA.id) {
              totalCoinsToDeduct += Math.abs(sourceOrder.amount)
              affectedOrders.push({
                order_id: usedTx.order_id,
                order_number: usedTx.order_number || 'Unknown',
                coins_used: Math.abs(sourceOrder.amount)
              })
            }
          }
        }
      }
      
      // Deduct coins
      await pool.query(`
        UPDATE users SET loyalty_points = loyalty_points - $1 WHERE id = $2
      `, [totalCoinsToDeduct, userId])
      
      const finalBalance = balanceBeforeCancel - totalCoinsToDeduct
      
      // Record reversal
      await pool.query(`
        INSERT INTO coin_transactions (user_id, amount, type, description, status, order_id, metadata)
        VALUES ($1, $2, 'cashback_reversed', $3, 'completed', $4, $5)
      `, [
        userId,
        -totalCoinsToDeduct,
        `Reversed ${cashbackCoins} cashback coins + ${totalCoinsToDeduct - cashbackCoins} coins used in other orders due to cancelled order ${orderA.order_number}`,
        orderA.id,
        JSON.stringify({
          original_cashback: cashbackCoins,
          coins_used_in_other_orders: totalCoinsToDeduct - cashbackCoins,
          affected_orders: affectedOrders,
          final_balance: finalBalance
        })
      ])
      
      // Create admin notification
      if (affectedOrders.length > 0) {
        await pool.query(`
          INSERT INTO admin_notifications (user_id, notification_type, title, message, link, icon, priority, metadata)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [
          userId,
          'coin_exploit_prevention',
          'Coins Deducted from Other Orders',
          `Order ${orderA.order_number} cancelled. ${totalCoinsToDeduct - cashbackCoins} coins that were used in ${affectedOrders.length} other order(s) have been deducted.`,
          `/admin/orders/${orderA.id}`,
          'alert-triangle',
          'high',
          JSON.stringify({
            cancelled_order: orderA.order_number,
            coins_deducted: totalCoinsToDeduct - cashbackCoins,
            affected_orders: affectedOrders,
            user_balance: finalBalance
          })
        ])
      }
      
      console.log(`   âœ… Exploit prevention logic executed`)
      console.log(`   ðŸ“Š Final balance: ${finalBalance} coins (${finalBalance < 0 ? 'NEGATIVE - Exploit prevented!' : 'positive'})`)
      console.log(`   ðŸ“‹ Affected orders: ${affectedOrders.length}`)
      if (affectedOrders.length > 0) {
        console.log(`      - ${affectedOrders.map(o => o.order_number).join(', ')}`)
      }
      console.log(`   ðŸ”” Admin notification: ${affectedOrders.length > 0 ? 'Created' : 'Not needed'}\n`)
      
      // Verify results
      console.log('ðŸ“Š Test Results:')
      console.log(`   âœ… Coins deducted: ${totalCoinsToDeduct} (${cashbackCoins} original + ${totalCoinsToDeduct - cashbackCoins} from other orders)`)
      console.log(`   âœ… Balance is ${finalBalance < 0 ? 'NEGATIVE' : 'positive'}: ${finalBalance} coins`)
      console.log(`   âœ… Reversal transaction created: Yes`)
      console.log(`   âœ… Admin notification created: ${affectedOrders.length > 0 ? 'Yes' : 'No'}`)
      
      if (finalBalance < 0) {
        console.log(`\nðŸŽ‰ SUCCESS: Exploit prevention is working! User balance went negative.`)
      } else {
        console.log(`\nâš ï¸  WARNING: Balance should be negative but is positive.`)
      }
    }
    
    await pool.end()
  } catch (err) {
    console.error('âŒ Error:', err.message)
    console.error(err.stack)
    await pool.end()
  }
}

runDirectTest()


