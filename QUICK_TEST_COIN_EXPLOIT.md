# Quick Test Guide - Coin Exploit Prevention

## Quick Start (5 minutes)

### Step 1: Start Your Server
```bash
cd backend
npm run dev
```

### Step 2: Create Test User (if needed)
```sql
-- Check if test user exists
SELECT id, email, loyalty_points FROM users WHERE email = 'test@example.com';

-- If not, create one (or use existing user)
INSERT INTO users (email, name, loyalty_points) 
VALUES ('test@example.com', 'Test User', 0)
ON CONFLICT (email) DO NOTHING;
```

### Step 3: Test via Database (Easiest Method)

#### A. Create Order A (earns 50 coins)
```sql
-- Insert order (₹1000)
INSERT INTO orders (
  order_number, customer_email, customer_name, 
  shipping_address, items, subtotal, total, 
  payment_method, payment_status, status
) VALUES (
  'TEST-ORDER-A-' || EXTRACT(EPOCH FROM NOW())::bigint,
  'test@example.com',
  'Test User',
  '{"name": "Test", "phone": "1234567890", "address": "Test"}'::jsonb,
  '[{"product_id": 1, "quantity": 1, "price": 1000}]'::jsonb,
  1000, 1000, 'razorpay', 'paid', 'confirmed'
) RETURNING id, order_number;
```

**Note:** The coin earning happens automatically when order is created via API. For database testing, manually add coins:
```sql
-- Manually add 50 coins (5% of ₹1000)
UPDATE users SET loyalty_points = loyalty_points + 50 
WHERE email = 'test@example.com';

-- Record the transaction
INSERT INTO coin_transactions (user_id, amount, type, description, status, order_id)
SELECT 
  id, 50, 'earned', 'Cashback 5% for order TEST-ORDER-A', 'completed', 
  (SELECT id FROM orders WHERE order_number LIKE 'TEST-ORDER-A%' ORDER BY id DESC LIMIT 1)
FROM users WHERE email = 'test@example.com';
```

#### B. Check Balance
```sql
SELECT email, loyalty_points FROM users WHERE email = 'test@example.com';
-- Should show: 50 coins
```

#### C. Create Order B using 50 coins
```sql
-- Insert order paid with coins
INSERT INTO orders (
  order_number, customer_email, customer_name,
  shipping_address, items, subtotal, total,
  payment_method, payment_status, status, coins_used
) VALUES (
  'TEST-ORDER-B-' || EXTRACT(EPOCH FROM NOW())::bigint,
  'test@example.com',
  'Test User',
  '{"name": "Test", "phone": "1234567890", "address": "Test"}'::jsonb,
  '[{"product_id": 1, "quantity": 1, "price": 500}]'::jsonb,
  500, 0, 'coins', 'paid', 'confirmed', 50
) RETURNING id, order_number;
```

**Note:** The coin deduction and source tracking happens via API. For database testing:
```sql
-- Get Order A's transaction ID
WITH order_a AS (
  SELECT id FROM orders WHERE order_number LIKE 'TEST-ORDER-A%' ORDER BY id DESC LIMIT 1
),
order_b AS (
  SELECT id FROM orders WHERE order_number LIKE 'TEST-ORDER-B%' ORDER BY id DESC LIMIT 1
),
source_tx AS (
  SELECT id, order_id FROM coin_transactions 
  WHERE order_id = (SELECT id FROM order_a) AND type = 'earned' LIMIT 1
)
-- Deduct coins and track source
UPDATE users SET loyalty_points = loyalty_points - 50 
WHERE email = 'test@example.com';

INSERT INTO coin_transactions (user_id, amount, type, description, status, order_id, metadata)
SELECT 
  u.id, -50, 'redeemed', 'Used 50 coins for order TEST-ORDER-B', 'completed',
  (SELECT id FROM order_b),
  jsonb_build_object(
    'source_orders', jsonb_build_array(
      jsonb_build_object(
        'transaction_id', st.id,
        'order_id', st.order_id,
        'order_number', (SELECT order_number FROM orders WHERE id = st.order_id),
        'amount', 50
      )
    ),
    'coins_used', 50,
    'order_number', (SELECT order_number FROM order_b)
  )
FROM users u, source_tx st
WHERE u.email = 'test@example.com';
```

#### D. Check Source Tracking
```sql
-- Verify source order tracking
SELECT 
  ct.id,
  ct.amount,
  ct.type,
  ct.metadata->'source_orders' as source_orders
FROM coin_transactions ct
WHERE ct.user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND ct.type = 'redeemed'
ORDER BY ct.created_at DESC
LIMIT 1;
```

#### E. Cancel Order A (The Exploit Test)
```sql
-- Mark Order A as delivered (required for cancellation)
UPDATE orders 
SET status = 'delivered', delivered_at = NOW() 
WHERE order_number LIKE 'TEST-ORDER-A%' 
ORDER BY id DESC LIMIT 1;

-- Create cancellation request
WITH order_a AS (
  SELECT id, order_number, customer_email, total 
  FROM orders 
  WHERE order_number LIKE 'TEST-ORDER-A%' 
  ORDER BY id DESC LIMIT 1
)
INSERT INTO order_cancellations (
  order_id, order_number, user_id, 
  cancellation_reason, cancellation_type, 
  refund_amount, status
)
SELECT 
  oa.id, oa.order_number, u.id,
  'Test cancellation', 'full', oa.total, 'approved'
FROM order_a oa, users u
WHERE u.email = oa.customer_email
RETURNING id;
```

**Now trigger the exploit prevention logic** (this is what happens in `approveCancellation`):

```sql
-- This simulates the exploit prevention logic from cancellations.ts
WITH cancelled_order AS (
  SELECT o.id, o.order_number, o.customer_email, o.total
  FROM orders o
  WHERE o.order_number LIKE 'TEST-ORDER-A%' 
  ORDER BY o.id DESC LIMIT 1
),
user_info AS (
  SELECT u.id, u.loyalty_points
  FROM users u, cancelled_order co
  WHERE u.email = co.customer_email
),
cashback_coins AS (
  SELECT ct.amount
  FROM coin_transactions ct, cancelled_order co, user_info ui
  WHERE ct.user_id = ui.id
    AND ct.type = 'earned'
    AND ct.order_id = co.id
    AND ct.amount > 0
    AND ct.description LIKE '%cashback%'
  ORDER BY ct.created_at DESC
  LIMIT 1
),
used_coins AS (
  SELECT 
    ct.id,
    ct.order_id,
    ct.amount,
    o.order_number,
    ct.metadata
  FROM coin_transactions ct
  LEFT JOIN orders o ON ct.order_id = o.id
  CROSS JOIN user_info ui
  WHERE ct.user_id = ui.id
    AND ct.type = 'redeemed'
    AND ct.amount < 0
    AND ct.metadata IS NOT NULL
    AND ct.metadata::text LIKE '%' || (SELECT id::text FROM cancelled_order) || '%'
    AND (o.status IS NULL OR o.status NOT IN ('cancelled'))
)
-- Deduct coins (this is the exploit prevention)
UPDATE users u
SET loyalty_points = loyalty_points - (
  SELECT COALESCE(cb.amount, 0) + COALESCE((
    SELECT SUM((source->>'amount')::int)
    FROM used_coins uc,
    jsonb_array_elements(uc.metadata->'source_orders') source
    WHERE (source->>'order_id')::int = (SELECT id FROM cancelled_order)
  ), 0)
  FROM cashback_coins cb
)
FROM user_info ui
WHERE u.id = ui.id
RETURNING u.email, u.loyalty_points;
```

#### F. Verify Exploit Prevention
```sql
-- Check final balance (should be negative!)
SELECT email, loyalty_points FROM users WHERE email = 'test@example.com';
-- Expected: -50 coins (negative balance)

-- Check reversal transaction
SELECT 
  ct.amount,
  ct.type,
  ct.description,
  ct.metadata->'affected_orders' as affected_orders,
  ct.metadata->'coins_used_in_other_orders' as coins_used
FROM coin_transactions ct
WHERE ct.user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND ct.type = 'cashback_reversed'
ORDER BY ct.created_at DESC
LIMIT 1;

-- Check admin notification
SELECT 
  notification_type,
  title,
  message,
  metadata
FROM admin_notifications
WHERE notification_type = 'coin_exploit_prevention'
ORDER BY created_at DESC
LIMIT 1;
```

---

## Testing via API (Recommended)

### Using Postman or curl

1. **Create Order A:**
```bash
curl -X POST http://localhost:2000/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "customer_email": "test@example.com",
    "customer_name": "Test User",
    "shipping_address": {"name": "Test", "phone": "1234567890", "address": "Test"},
    "items": [{"product_id": 1, "quantity": 1, "price": 1000, "name": "Test Product"}],
    "subtotal": 1000,
    "total": 1000,
    "payment_method": "razorpay",
    "payment_status": "paid"
  }'
```

2. **Create Order B using coins:**
```bash
curl -X POST http://localhost:2000/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "customer_email": "test@example.com",
    "customer_name": "Test User",
    "shipping_address": {"name": "Test", "phone": "1234567890", "address": "Test"},
    "items": [{"product_id": 1, "quantity": 1, "price": 500, "name": "Test Product"}],
    "subtotal": 500,
    "total": 0,
    "coins_used": 50,
    "payment_method": "coins",
    "payment_status": "paid"
  }'
```

3. **Cancel Order A:**
   - First mark as delivered (via admin panel or database)
   - Then request cancellation via API
   - Approve cancellation (requires admin auth)

---

## Automated Testing

Run the automated test script:

```bash
cd backend
npm run test:coin-exploit
```

Or:
```bash
node backend/test-coin-exploit.js
```

---

## Expected Results

✅ **Success Indicators:**
- User balance goes negative when exploit is attempted
- `cashback_reversed` transaction created with metadata
- Admin notification created
- Source orders tracked in `redeemed` transaction metadata

❌ **Failure Indicators:**
- User balance stays positive after cancellation
- No reversal transaction created
- No admin notification
- Missing source order tracking

---

## Cleanup After Testing

```sql
-- Delete test orders
DELETE FROM orders WHERE customer_email = 'test@example.com' AND order_number LIKE 'TEST-%';

-- Delete test transactions
DELETE FROM coin_transactions 
WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND (description LIKE '%TEST-%' OR description LIKE '%Test%');

-- Reset balance
UPDATE users SET loyalty_points = 0 WHERE email = 'test@example.com';

-- Delete test notifications
DELETE FROM admin_notifications WHERE notification_type = 'coin_exploit_prevention';
```


