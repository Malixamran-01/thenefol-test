/**
 * Automated Test Script for Coin Exploit Prevention
 * 
 * This script tests the coin exploit prevention system by:
 * 1. Creating orders that generate coins
 * 2. Using those coins in new orders
 * 3. Cancelling the original orders
 * 4. Verifying that coins are properly deducted
 * 
 * Usage:
 *   node test-coin-exploit.js
 * 
 * Prerequisites:
 *   - Node.js 18+ (for built-in fetch API) or install node-fetch
 *   - Backend server running on http://localhost:2000
 *   - PostgreSQL database configured
 *   - Test user exists in database
 *   - Set TEST_USER_EMAIL in .env or use default 'test@example.com'
 *   - Optional: Set TEST_AUTH_TOKEN in .env for authenticated API calls
 * 
 * Note: If using Node.js < 18, install node-fetch:
 *   npm install node-fetch@2
 *   Then add at top: const fetch = require('node-fetch')
 */

const { Pool } = require('pg')
require('dotenv').config()

// Database connection - use DATABASE_URL if available, otherwise use individual settings
let pool
if (process.env.DATABASE_URL) {
  try {
    pool = new Pool({ connectionString: process.env.DATABASE_URL })
  } catch (err) {
    console.log('âš ï¸  Failed to connect with DATABASE_URL, trying fallback...')
    pool = new Pool({
      host: process.env.DB_HOST || 'localhost',
      port: process.env.DB_PORT || 5432,
      database: process.env.DB_NAME || 'nefol',
      user: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASSWORD || 'postgres',
    })
  }
} else {
  pool = new Pool({
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'nefol',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres',
  })
}

// Test configuration
const TEST_USER_EMAIL = process.env.TEST_USER_EMAIL || 'test@example.com'
const API_BASE_URL = process.env.API_URL || 'http://localhost:2000'
const TEST_AUTH_TOKEN = process.env.TEST_AUTH_TOKEN || '' // Add if needed

// Test results
const results = {
  passed: 0,
  failed: 0,
  tests: []
}

// Helper function to log test results
function logTest(name, passed, message = '') {
  results.tests.push({ name, passed, message })
  if (passed) {
    results.passed++
    console.log(`âœ… ${name}: ${message || 'PASSED'}`)
  } else {
    results.failed++
    console.error(`âŒ ${name}: ${message || 'FAILED'}`)
  }
}

// Helper function to make API requests
async function apiRequest(method, endpoint, data = null, headers = {}) {
  try {
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      }
    }
    
    if (data) {
      options.body = JSON.stringify(data)
    }
    
    const response = await fetch(`${API_BASE_URL}${endpoint}`, options)
    const result = await response.json()
    
    return { ok: response.ok, status: response.status, data: result }
  } catch (error) {
    return { ok: false, error: error.message }
  }
}

// Helper function to get user ID
async function getUserId(email) {
  const result = await pool.query('SELECT id FROM users WHERE email = $1', [email])
  return result.rows[0]?.id
}

// Helper function to get user balance
async function getUserBalance(email) {
  const result = await pool.query(
    'SELECT loyalty_points FROM users WHERE email = $1',
    [email]
  )
  return result.rows[0]?.loyalty_points || 0
}

// Helper function to create an order
async function createOrder(orderData) {
  const response = await apiRequest('POST', '/api/orders', orderData)
  return response
}

// Helper function to get coin transactions
async function getCoinTransactions(userId, type = null) {
  let query = `
    SELECT id, amount, type, description, metadata, created_at, order_id
    FROM coin_transactions
    WHERE user_id = $1
  `
  const params = [userId]
  
  if (type) {
    query += ' AND type = $2'
    params.push(type)
  }
  
  query += ' ORDER BY created_at DESC'
  
  const result = await pool.query(query, params)
  return result.rows
}

// Helper function to cancel an order via API
async function cancelOrder(orderNumber, authToken = '') {
  // First, mark order as delivered (required for cancellation request)
  await pool.query(
    `UPDATE orders SET status = 'delivered', delivered_at = NOW() WHERE order_number = $1`,
    [orderNumber]
  )
  
  // Request cancellation
  const requestResponse = await apiRequest(
    'POST',
    '/api/cancellations/request',
    {
      order_number: orderNumber,
      reason: 'Test cancellation for coin exploit testing',
      cancellation_type: 'full'
    },
    authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
  )
  
  if (!requestResponse.ok) {
    console.log(`   âš ï¸  Cancellation request failed: ${JSON.stringify(requestResponse.data)}`)
    // Try direct cancellation if request fails
    return await cancelOrderDirect(orderNumber)
  }
  
  const cancellationId = requestResponse.data?.cancellation?.id || requestResponse.data?.id
  
  if (!cancellationId) {
    console.log(`   âš ï¸  No cancellation ID returned, trying direct cancellation`)
    return await cancelOrderDirect(orderNumber)
  }
  
  // Approve cancellation (this triggers the exploit prevention logic)
  const approveResponse = await apiRequest(
    'PUT',
    `/api/cancellations/${cancellationId}/approve`,
    { admin_notes: 'Test approval for coin exploit testing' },
    authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
  )
  
  if (approveResponse.ok) {
    return { success: true, cancellationId }
  } else {
    console.log(`   âš ï¸  Cancellation approval failed: ${JSON.stringify(approveResponse.data)}`)
    return await cancelOrderDirect(orderNumber)
  }
}

// Helper function to cancel order directly (fallback)
async function cancelOrderDirect(orderNumber) {
  // Get order details
  const orderResult = await pool.query(
    'SELECT * FROM orders WHERE order_number = $1',
    [orderNumber]
  )
  
  if (orderResult.rows.length === 0) {
    return { success: false, error: 'Order not found' }
  }
  
  const order = orderResult.rows[0]
  
  // Mark as delivered first
  await pool.query(
    `UPDATE orders SET status = 'delivered', delivered_at = NOW() WHERE order_number = $1`,
    [orderNumber]
  )
  
  // Create cancellation record
  const cancellationResult = await pool.query(
    `INSERT INTO order_cancellations 
    (order_id, order_number, user_id, cancellation_reason, cancellation_type, refund_amount, status)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING *`,
    [
      order.id,
      orderNumber,
      await getUserId(order.customer_email),
      'Test cancellation',
      'full',
      parseFloat(order.total || 0),
      'approved'
    ]
  )
  
  // Update order status
  await pool.query(
    `UPDATE orders SET status = 'cancelled' WHERE order_number = $1`,
    [orderNumber]
  )
  
  // Note: The exploit prevention logic will run when the cancellation is processed
  // For full testing, you should import and call the actual cancellation handler
  // For now, this creates the cancellation record which should trigger the logic
  
  return { success: true, cancellationId: cancellationResult.rows[0]?.id }
}

// Test 1: Normal coin earning
async function testNormalCoinEarning() {
  console.log('\nðŸ“¦ Test 1: Normal Coin Earning')
  
  const initialBalance = await getUserBalance(TEST_USER_EMAIL)
  
  const orderData = {
    customer_email: TEST_USER_EMAIL,
    customer_name: 'Test User',
    shipping_address: {
      name: 'Test User',
      phone: '1234567890',
      address: '123 Test Street',
      city: 'Test City',
      state: 'Test State',
      pincode: '123456'
    },
    items: [{ product_id: 1, quantity: 1, price: 1000, name: 'Test Product' }],
    subtotal: 1000,
    total: 1000,
    payment_method: 'razorpay',
    payment_status: 'paid'
  }
  
  const response = await createOrder(orderData)
  
  if (!response.ok) {
    logTest('Create Order A', false, `Failed to create order: ${JSON.stringify(response.data)}`)
    return null
  }
  
  logTest('Create Order A', true, `Order created: ${response.data.order?.order_number || 'N/A'}`)
  
  // Wait a bit for coin processing
  await new Promise(resolve => setTimeout(resolve, 1000))
  
  const finalBalance = await getUserBalance(TEST_USER_EMAIL)
  const coinsEarned = finalBalance - initialBalance
  
  logTest('Coins Earned', coinsEarned === 50, `Expected 50, got ${coinsEarned}`)
  
  return response.data.order
}

// Test 2: Using coins for payment
async function testUsingCoins(orderA) {
  console.log('\nðŸ’° Test 2: Using Coins for Payment')
  
  const userId = await getUserId(TEST_USER_EMAIL)
  const balanceBefore = await getUserBalance(TEST_USER_EMAIL)
  
  if (balanceBefore < 50) {
    logTest('Sufficient Balance', false, `Need at least 50 coins, have ${balanceBefore}`)
    return null
  }
  
  const orderData = {
    customer_email: TEST_USER_EMAIL,
    customer_name: 'Test User',
    shipping_address: {
      name: 'Test User',
      phone: '1234567890',
      address: '123 Test Street',
      city: 'Test City',
      state: 'Test State',
      pincode: '123456'
    },
    items: [{ product_id: 1, quantity: 1, price: 500, name: 'Test Product' }],
    subtotal: 500,
    total: 0, // Fully paid with coins
    coins_used: 50,
    payment_method: 'coins',
    payment_status: 'paid'
  }
  
  const response = await createOrder(orderData)
  
  if (!response.ok) {
    logTest('Create Order with Coins', false, `Failed: ${JSON.stringify(response.data)}`)
    return null
  }
  
  logTest('Create Order with Coins', true, `Order created: ${response.data.order?.order_number || 'N/A'}`)
  
  // Wait for processing
  await new Promise(resolve => setTimeout(resolve, 1000))
  
  const balanceAfter = await getUserBalance(TEST_USER_EMAIL)
  logTest('Coins Deducted', balanceAfter === balanceBefore - 50, 
    `Expected ${balanceBefore - 50}, got ${balanceAfter}`)
  
  // Check if source order tracking exists
  const transactions = await getCoinTransactions(userId, 'redeemed')
  const latestTransaction = transactions[0]
  
  if (latestTransaction && latestTransaction.metadata) {
    const metadata = typeof latestTransaction.metadata === 'string' 
      ? JSON.parse(latestTransaction.metadata) 
      : latestTransaction.metadata
    
    const hasSourceOrders = metadata.source_orders && Array.isArray(metadata.source_orders)
    logTest('Source Order Tracking', hasSourceOrders, 
      hasSourceOrders ? 'Source orders tracked' : 'No source orders in metadata')
    
    if (hasSourceOrders && metadata.source_orders.length > 0) {
      const sourceOrder = metadata.source_orders[0]
      logTest('Source Order Contains Order A', 
        sourceOrder.order_id === orderA.id || sourceOrder.order_number === orderA.order_number,
        `Source order: ${JSON.stringify(sourceOrder)}`)
    }
  } else {
    logTest('Source Order Tracking', false, 'No metadata found in transaction')
  }
  
  return response.data.order
}

// Test 3: Exploit prevention (cancelling order after using coins)
async function testExploitPrevention(orderA, orderB) {
  console.log('\nðŸ›¡ï¸ Test 3: Exploit Prevention')
  
  const userId = await getUserId(TEST_USER_EMAIL)
  const balanceBeforeCancellation = await getUserBalance(TEST_USER_EMAIL)
  
  // Cancel Order A
  console.log(`   Cancelling Order A: ${orderA.order_number}`)
  const cancelResult = await cancelOrder(orderA.order_number, TEST_AUTH_TOKEN)
  
  if (!cancelResult.success) {
    logTest('Cancel Order A', false, `Failed to cancel order: ${cancelResult.error || 'Unknown error'}`)
    return
  }
  
  logTest('Cancel Order A', true, `Order cancelled (Cancellation ID: ${cancelResult.cancellationId || 'N/A'})`)
  
  // Wait for cancellation processing (coin reversal happens in approveCancellation)
  await new Promise(resolve => setTimeout(resolve, 3000))
  
  const balanceAfterCancellation = await getUserBalance(TEST_USER_EMAIL)
  
  // Check if coins were deducted (balance should be negative if coins from Order A were used)
  const expectedBalance = balanceBeforeCancellation - 50 // 50 coins from Order A
  
  logTest('Coins Deducted on Cancellation', 
    balanceAfterCancellation <= balanceBeforeCancellation - 50,
    `Balance: ${balanceBeforeCancellation} â†’ ${balanceAfterCancellation} (expected â‰¤ ${expectedBalance})`)
  
  // Check for cashback_reversed transaction
  const reversedTransactions = await getCoinTransactions(userId, 'cashback_reversed')
  const hasReversal = reversedTransactions.length > 0 && 
    reversedTransactions.some(tx => {
      const metadata = typeof tx.metadata === 'string' ? JSON.parse(tx.metadata) : tx.metadata
      return metadata && (metadata.affected_orders || metadata.coins_used_in_other_orders > 0)
    })
  
  logTest('Reversal Transaction Created', hasReversal, 
    hasReversal ? 'Reversal transaction with affected orders found' : 'No reversal transaction found')
  
  // Check admin notifications
  const notificationResult = await pool.query(
    `SELECT * FROM admin_notifications 
     WHERE notification_type = 'coin_exploit_prevention' 
     AND user_id = $1
     ORDER BY created_at DESC LIMIT 1`,
    [userId]
  )
  
  const hasNotification = notificationResult.rows.length > 0
  logTest('Admin Notification Created', hasNotification,
    hasNotification ? 'Admin notification found' : 'No admin notification found')
  
  if (hasNotification) {
    const notification = notificationResult.rows[0]
    const metadata = typeof notification.metadata === 'string' 
      ? JSON.parse(notification.metadata) 
      : notification.metadata
    
    logTest('Notification Contains Affected Orders', 
      metadata && metadata.affected_orders && metadata.affected_orders.length > 0,
      `Affected orders: ${metadata?.affected_orders?.length || 0}`)
  }
}

// Main test runner
async function runTests() {
  console.log('ðŸ§ª Starting Coin Exploit Prevention Tests')
  console.log(`ðŸ“§ Test User: ${TEST_USER_EMAIL}`)
  console.log(`ðŸŒ API URL: ${API_BASE_URL}\n`)
  
  try {
    // Test 1: Create Order A and earn coins
    const orderA = await testNormalCoinEarning()
    if (!orderA) {
      console.log('\nâŒ Test 1 failed, skipping remaining tests')
      return
    }
    
    // Test 2: Use coins from Order A in Order B
    const orderB = await testUsingCoins(orderA)
    if (!orderB) {
      console.log('\nâŒ Test 2 failed, skipping remaining tests')
      return
    }
    
    // Test 3: Cancel Order A and verify exploit prevention
    await testExploitPrevention(orderA, orderB)
    
  } catch (error) {
    console.error('\nâŒ Test execution error:', error)
    logTest('Test Execution', false, error.message)
  } finally {
    // Print summary
    console.log('\n' + '='.repeat(50))
    console.log('ðŸ“Š Test Summary')
    console.log('='.repeat(50))
    console.log(`âœ… Passed: ${results.passed}`)
    console.log(`âŒ Failed: ${results.failed}`)
    console.log(`ðŸ“ Total: ${results.tests.length}`)
    
    if (results.failed > 0) {
      console.log('\nâŒ Failed Tests:')
      results.tests
        .filter(t => !t.passed)
        .forEach(t => console.log(`   - ${t.name}: ${t.message}`))
    }
    
    console.log('\n')
  }
  
  await pool.end()
}

// Run tests
if (require.main === module) {
  runTests().catch(console.error)
}

module.exports = { runTests }

